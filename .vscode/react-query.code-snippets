{
  "React Query - useQuery Hook": {
    "prefix": "rq-query",
    "body": [
      "const { data: ${1:data}, isLoading, isError, error, refetch } = use${2:Entity}Query({",
      "  ${3:// options}",
      "});",
      "",
      "if (isLoading) return <${4:LoadingSpinner} />;",
      "if (isError) return <${5:ErrorDisplay} error={error} />;",
      "",
      "$0"
    ],
    "description": "Create a React Query useQuery hook with loading and error handling"
  },
  
  "React Query - useMutation Hook": {
    "prefix": "rq-mutation",
    "body": [
      "const { mutate: ${1:mutationName}, isPending, isError, error } = use${2:Action}Mutation({",
      "  onSuccess: (data) => {",
      "    ${3:// Handle success}",
      "  },",
      "  onError: (error) => {",
      "    Alert.alert('Error', error.message);",
      "  },",
      "});",
      "",
      "$0"
    ],
    "description": "Create a React Query useMutation hook with callbacks"
  },
  
  "React Query - useInfiniteQuery Hook": {
    "prefix": "rq-infinite",
    "body": [
      "const {",
      "  data,",
      "  fetchNextPage,",
      "  hasNextPage,",
      "  isFetchingNextPage,",
      "  isLoading,",
      "} = use${1:Entity}Query({",
      "  ${2:// options}",
      "});",
      "",
      "const ${3:items} = data?.pages.flatMap(page => page.items) ?? [];",
      "",
      "$0"
    ],
    "description": "Create a React Query useInfiniteQuery hook for pagination"
  },
  
  "React Query - Query with Filters": {
    "prefix": "rq-query-filters",
    "body": [
      "const { data: ${1:data} = [], isLoading, error } = use${2:Entity}Query({",
      "  filters: {",
      "    ${3:category}: '${4:value}',",
      "    ${5:limit}: ${6:20},",
      "  },",
      "  enabled: ${7:true},",
      "});",
      "",
      "$0"
    ],
    "description": "Create a React Query hook with filters"
  },
  
  "React Query - Mutation with Optimistic Update": {
    "prefix": "rq-mutation-optimistic",
    "body": [
      "const { mutate: ${1:mutationName} } = use${2:Action}Mutation({",
      "  onMutate: async (variables) => {",
      "    // Cancel outgoing refetches",
      "    await queryClient.cancelQueries({ queryKey: queryKeys.${3:entity}.${4:scope}(${5:id}) });",
      "    ",
      "    // Snapshot previous value",
      "    const previous = queryClient.getQueryData(queryKeys.${3:entity}.${4:scope}(${5:id}));",
      "    ",
      "    // Optimistically update",
      "    queryClient.setQueryData(queryKeys.${3:entity}.${4:scope}(${5:id}), (old) => ({",
      "      ...old,",
      "      ${6:property}: ${7:newValue},",
      "    }));",
      "    ",
      "    return { previous };",
      "  },",
      "  onError: (err, variables, context) => {",
      "    // Rollback on error",
      "    if (context?.previous) {",
      "      queryClient.setQueryData(queryKeys.${3:entity}.${4:scope}(${5:id}), context.previous);",
      "    }",
      "  },",
      "  onSettled: () => {",
      "    // Always refetch after mutation",
      "    queryClient.invalidateQueries({ queryKey: queryKeys.${3:entity}.${4:scope}(${5:id}) });",
      "  },",
      "});",
      "",
      "$0"
    ],
    "description": "Create a mutation with optimistic updates and rollback"
  },
  
  "React Query - Invalidate Queries": {
    "prefix": "rq-invalidate",
    "body": [
      "queryClient.invalidateQueries({ queryKey: queryKeys.${1:entity}.${2:scope}(${3:id}) });$0"
    ],
    "description": "Invalidate queries to trigger refetch"
  },
  
  "React Query - Prefetch Query": {
    "prefix": "rq-prefetch",
    "body": [
      "queryClient.prefetchQuery({",
      "  queryKey: queryKeys.${1:entity}.${2:scope}(${3:id}),",
      "  queryFn: () => ${4:Service}.${5:method}(${3:id}),",
      "});$0"
    ],
    "description": "Prefetch a query before navigation"
  },
  
  "React Query - Set Query Data": {
    "prefix": "rq-set-data",
    "body": [
      "queryClient.setQueryData(",
      "  queryKeys.${1:entity}.${2:scope}(${3:id}),",
      "  (oldData) => ({",
      "    ...oldData,",
      "    ${4:property}: ${5:newValue},",
      "  })",
      ");$0"
    ],
    "description": "Manually update query data in cache"
  },
  
  "React Query - Get Query Data": {
    "prefix": "rq-get-data",
    "body": [
      "const ${1:data} = queryClient.getQueryData(queryKeys.${2:entity}.${3:scope}(${4:id}));$0"
    ],
    "description": "Get query data from cache"
  },
  
  "React Query - Query Key": {
    "prefix": "rq-key",
    "body": [
      "queryKeys.${1:entity}.${2:scope}(${3:id})$0"
    ],
    "description": "Insert a query key from the factory"
  },
  
  "React Query - Dependent Query": {
    "prefix": "rq-dependent",
    "body": [
      "const { data: ${1:firstData} } = use${2:First}Query({ ${3:id} });",
      "",
      "const { data: ${4:secondData} } = use${5:Second}Query({",
      "  ${6:id},",
      "  enabled: !!${1:firstData}, // Only run if first query succeeds",
      "});",
      "",
      "$0"
    ],
    "description": "Create dependent queries that run sequentially"
  },
  
  "React Query - FlatList with Infinite Scroll": {
    "prefix": "rq-flatlist-infinite",
    "body": [
      "const {",
      "  data,",
      "  fetchNextPage,",
      "  hasNextPage,",
      "  isFetchingNextPage,",
      "  isLoading,",
      "} = use${1:Entity}Query({ ${2:userId}: user.id });",
      "",
      "const ${3:items} = data?.pages.flatMap(page => page.items) ?? [];",
      "",
      "if (isLoading) return <${4:LoadingSpinner} />;",
      "",
      "return (",
      "  <FlatList",
      "    data={${3:items}}",
      "    renderItem={({ item }) => <${5:ItemComponent} item={item} />}",
      "    onEndReached={() => hasNextPage && fetchNextPage()}",
      "    onEndReachedThreshold={0.5}",
      "    ListFooterComponent={",
      "      isFetchingNextPage ? <${6:LoadingSpinner} /> : null",
      "    }",
      "  />",
      ");$0"
    ],
    "description": "Create a FlatList with infinite scroll using React Query"
  },
  
  "React Query - Pull to Refresh": {
    "prefix": "rq-pull-refresh",
    "body": [
      "const { data: ${1:data} = [], isFetching, refetch } = use${2:Entity}Query({",
      "  ${3:// options}",
      "});",
      "",
      "return (",
      "  <FlatList",
      "    data={${1:data}}",
      "    renderItem={({ item }) => <${4:ItemComponent} item={item} />}",
      "    refreshControl={",
      "      <RefreshControl",
      "        refreshing={isFetching}",
      "        onRefresh={refetch}",
      "      />",
      "    }",
      "  />",
      ");$0"
    ],
    "description": "Add pull-to-refresh to a FlatList with React Query"
  },
  
  "React Query - Custom Hook Template": {
    "prefix": "rq-custom-hook",
    "body": [
      "import { useQuery, UseQueryOptions } from '@tanstack/react-query';",
      "import { queryKeys } from '../../lib/queryKeys';",
      "import { ${1:Service} } from '../../services/api/${2:service}';",
      "import type { ${3:Entity} } from '../../types';",
      "",
      "export interface Use${3:Entity}QueryOptions {",
      "  ${4:id}: string;",
      "  enabled?: boolean;",
      "  staleTime?: number;",
      "}",
      "",
      "export function use${3:Entity}Query(options: Use${3:Entity}QueryOptions) {",
      "  const { ${4:id}, enabled = true, staleTime } = options;",
      "",
      "  return useQuery({",
      "    queryKey: queryKeys.${5:entities}.${6:scope}(${4:id}),",
      "    queryFn: () => ${1:Service}.${7:method}(${4:id}),",
      "    enabled,",
      "    staleTime,",
      "  });",
      "}$0"
    ],
    "description": "Create a custom React Query hook template"
  },
  
  "React Query - Custom Mutation Template": {
    "prefix": "rq-custom-mutation",
    "body": [
      "import { useMutation, useQueryClient } from '@tanstack/react-query';",
      "import { queryKeys } from '../../lib/queryKeys';",
      "import { ${1:Service} } from '../../services/api/${2:service}';",
      "import type { ${3:Entity} } from '../../types';",
      "",
      "export interface ${4:Action}MutationData {",
      "  ${5:id}: string;",
      "  ${6:// other fields}",
      "}",
      "",
      "export interface Use${4:Action}MutationOptions {",
      "  onSuccess?: (data: ${3:Entity}) => void;",
      "  onError?: (error: Error) => void;",
      "}",
      "",
      "export function use${4:Action}Mutation(options?: Use${4:Action}MutationOptions) {",
      "  const queryClient = useQueryClient();",
      "",
      "  return useMutation({",
      "    mutationFn: (data: ${4:Action}MutationData) => ${1:Service}.${7:method}(data),",
      "    onSuccess: (data, variables) => {",
      "      // Invalidate related queries",
      "      queryClient.invalidateQueries({ queryKey: queryKeys.${8:entities}.${9:scope}(variables.${5:id}) });",
      "      options?.onSuccess?.(data);",
      "    },",
      "    onError: (error: Error) => {",
      "      options?.onError?.(error);",
      "    },",
      "  });",
      "}$0"
    ],
    "description": "Create a custom React Query mutation template"
  }
}
